# تـوازي (Threading)
[[English]](readme.md)

مكتبة لإنشاء المسالك (threads) وتمكين المزامنة (synchronization) بينها في لغة الأسس.

## إضافة المكتبة للمشروع

أضف المكتبة لمشروعك باستخدام مدير الحزم:

<div dir="rtl">

```
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Threading"، "تـوازي.أسس")؛
```

</div>

```
import "Apm";
Apm.importFile("Alusus/Threading");
```


## الدالات

### أنشئ_مسلكا (createThread)

<div dir="rtl">

```
    دالة أنشئ_مسلكا(
      مسلك: مؤشر[مـسلك]،
      مزايا: مؤشر[مـزايا_المسلك]،
      دالة_البداية: مؤشر[دالة (مؤشر): مؤشر]،
      معطى: مؤشر
    ): صـحيح؛
```

</div>

```
    func createThread(
      pthread: ptr[Thread],
      attr: ptr[ThreadAttributes],
      startRoutine: ptr[func (ptr): ptr],
      arg: ptr
    ): Int;
```
دالة  لإنشاء مسلك. تطابق هذه الدالة دالة `pthread_create` من Posix.

المعطيات:

`مسلك`: مؤشر إلى متغير من الصنف `مـسلك` (`Thread`) تُخزن فيه بيانات المسلك المُنشأ.

`مزايا`: السمات التي نريدها للمسلك.

`دالة_البداية`: مؤشر إلى الدالة التي ستُنفذ في المسلك الجديد.

`معطى`: مؤشر يتم تمريره للدالة عند تشغيل المسلك. يستخدم هذا المؤشر لتمرير أي بيانات نريد تمريرها للدالة.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### التق_بمسلك (joinThread)

<div dir="rtl">

```
    دالة التق_بمسلك(مسلك: مؤشر[مـسلك]، نتيجة: مؤشر[مؤشر]): صـحيح؛
```

</div>

```
    func joinThread(pthread: ptr[Thread], retval: ptr[ptr]): Int;
```
تنتظر مسلكا حتى يكتمل تنفيذه وتستلم منه القيمة المرجعة من دالة المسلك. هذه الدالة تطابق دالة `pthread_join` من Posix.

المعطيات:

`مسلك`: مؤشر للمسلك الذي نرغب بانتظاره.

`نتيجة`: مؤشر إلى المتغير الذي ستُخزن فيه نتيجة تنفيذ المسلك، أي القيمة المرجعة من دالة المسلك.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### هيئ_مزامنا (initMutex)

<div dir="rtl">

```
    دالة هيئ_مزامنا(مزامن: مؤشر[مـزامن]، مزايا: مؤشر[مـزايا_مزامن]): صـحيح؛
```

</div>

```
    func initMutex(mutex: ptr[Mutex], attrs: ptr[MutexAttributes]): Int;
```
تهيئ مزامنا. يجب تهيئة المزامن باستخدام هذه الدالة قبل التمكن من استخدامه.
هذه الدالة تطابق دالة `pthread_mutex_init` من Posix.

المعطيات:

`مزامن`: مؤشر إلى المزامن المراد تهيئته.

`مزايا`: المزايا المطلوبة لهذا المزامن. تمرير 0 يؤدي لتهيئة المزامن بالمزايا الافتراضية.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### اقفل_مزامنا (lockMutex)

<div dir="rtl">

```
    دالة اقفل_مزامنا(مزامن: مؤشر[مـزامن]): صـحيح؛
```

</div>

```
    func lockMutex(mutex: ptr[Mutex]): Int;
```
تقفل المزامن وتحجزه للمسلك الحالي. إن كان المزامن محجوزا من قبل مسلك آخر فسيُجمد هذا المسلك حتى يتم تحرير المزامن من قبل المسلك الآخر.
هذه الدالة تطابق دالة `pthread_mutex_lock` من Posix.

المعطيات:

`مزامن`: مؤشر على المزامن المراد قفله.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### حاول_قفل_مزامن (tryLockMutex)

<div dir="rtl">

```
    دالة حاول_قفل_مزامن(مزامن: مؤشر[مـزامن]): صـحيح؛
```

</div>

```
    func tryLockMutex(mutex: ptr[Mutex]): Int;
```
تقفل المزامن إذا كان حرًا، وتُرجع رمز خطأ مباشرة دون انتظار إذا كان المزامن محجوزًا من قبل مسلك آخر.
هذه الدالة تطابق دالة `pthread_mutex_trylock` من Posix.

المعطيات:

`مزامن`: مؤشر على المزامن المراد قفله.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### افتح_مزامنا (unlockMutex)

<div dir="rtl">

```
    دالة افتح_مزامنا(مزامن: مؤشر[مـزامن]): صـحيح؛
```

</div>

```
    func unlockMutex(mutex: ptr[Mutex]): Int;
```
تحرر مزامنًا وتجعله متوفرًا للمسالك الأخرى. هذه الدالة تطابق دالة `pthread_mutex_unlock` من Posix.

المعطيات:

`مزامن`: مؤشر إلى المزامن المراد تحريره.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### هيئ_شرطا (initCond)

<div dir="rtl">

```
    دالة هيئ_شرطا(شرط: مؤشر[شـرط]، مزايا: مؤشر[مـزايا_شرط]): صـحيح؛
```

</div>

```
    func initCond(cond: ptr[Cond], attrs: ptr[CondAttributes]): Int;
```
يهيئ كائنا من صنف `شـرط`. يجب تهيئة الشرط بهذه الدالة قبل استخدامه.
هذه الدالة تطابق دالة `pthread_cond_init` من Posix.

المعطيات:

`شرد`: مؤشر إلى الشرط المراد تهيئته.

`مزايا`: المزايا المطلوبة للشرط. تمرير 0 يؤدي إلى تهيئته بالمزايا الافتراضية.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### علم_شرطا (signalCond)

<div dir="rtl">

```
    دالة علم_شرطا(شرط: مؤشر[شـرط]): صـحيح؛
```

</div>

```
    func signalCond(cond: ptr[Cond]): Int;
```
يُرسل إشارة بأن الشرط المعني قد تحقق. يؤدي ذلك لتحرير مسلك واحد من المسالك المنتظرة لهذا الشرط. إن
وُجد عدة مسالك تنتظر الشرط فسيُحرر واحد منها فقط لكل استدعاء لهذه الدالة. قبل استدعاء هذه الدالة
يجب على المسلك قفل مزامن (نفس المزامن المستخدم من قبل المسالك التي تستدعي `انتظر_شرطا` `waitCond`) ويجب تحرير
المزامن بعد استدعاء هذه الدالة. المسلك الذي ينتظر تحقق الشرط باستخدام الدالة `انتظر_شرطا` `waitCond`
لن يُحرر حتى يُحرر هذا المزامن لأن دالة `انتظر_شرطا` ستسعى لقفل ذلك المزامن.
هذه الدالة تطابق دالة `pthread_cond_signal` من Posix.

المعطيات:

`شرط`: مؤشر إلى الشرط المراد تعليمه.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### انتظر_شرطا (waitCond)

<div dir="rtl">

```
    دالة انتظر_شرطا(شرط: مؤشر[شـرط]، مزامن: مؤشر[مـزامن]): صـحيح؛
```

</div>

```
    func waitCond(cond: ptr[Cond], mutex: ptr[Mutex]): Int;
```
تنتظر تحقق شرط. تستقبل هذه الدالة مزامنا بالإضافة إلى الشرط المعني وتتطلب أن يكون المزامن مقفلًا
قبل استداءها. تعمل الدالة بشكل لا انشطاري (atomic) على تجميد المسلك وتحرير المزامن. عند تحقق
الشرط تقوم الدالة بشكل لا انشطاري بقفل المزامن مجددًا وتحرير المسلك.
هذه الدالة تطابق دالة `pthread_cond_wait` من Posix.

المعطيات:

`شرط`: مؤشر إلى الشرط المراد انتظار تحققه.

`مزامن`: مؤشر إلى مزامن. يجب أن يكون المزامن مقفلًا قبل استدعاء الدالة.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.


## الأصناف

### مـزايا_مسلك (ThreadAttributes)

<div dir=rtl>

```
صنف مـزايا_مسلك {
    عرف أعلام: صـحيح؛
    عرف حجم_المكدس: صـحيح؛
    عرف مجال_التنافس: صـحيح؛
    عرف توريث_الجدولة: صـحيح؛
    عرف فصل_الحالة: صـحيح؛
    عرف جدولة: صـحيح؛
    عرف معلمة: مـعامل_جدولة؛
    عرف وقت_البداية: تـفصيل_زمني؛
    عرف حد_اقصى: تـفصيل_زمني؛
    عرف فترة: تـفصيل_زمني؛
}
```

</div>

```
class ThreadAttributes {
    def flags: Int;
    def stackSize: Int;
    def contentionScope: Int;
    def inheritSched: Int;
    def detachState: Int;
    def sched: Int;
    def param: SchedParam;
    def startTime: TimeSpec;
    def deadLine: TimeSpec;
    def period: TimeSpec;
}
```

### مـعامل_جدولة (SchedParam)

<div dir=rtl>

```
صنف مـعامل_جدولة {
    عرف أولوية_الجدولة: صـحيح؛
}؛
```

</div>

```
class SchedParam {
    def schedPriority: Int;
}
```

### تـفصيل_زمني (TimeSpec)

<div dir=rtl>

```
صنف تـفصيل_زمني {
    عرف مدة_ثواني: صـحيح_متكيف؛
    عرف مدة_نانو: صـحيح[64]؛
}
```

</div>

```
class TimeSpec {
    def tvSec: ArchInt;
    def tvNsec: Int[64];
}
```

### مـزامن (Mutex)

يستخدم للمزامنة بين المسالك المختلفة ويتم ذلك بطلب المسلك قفل المزامن، ومن ثم بعد الحصول على
القفل يقوم بالعمل المراد ثم يحرر القفل ليتسنى لمسلك آخر قفله.

* `هيئ`: دالة لتهيئة المزامن. يجب استدعاء هذه الدالة قبل استخدام المزامن. لها صيغتان:

<div dir=rtl>

```
عملية هذا.هيئ()؛
عملية هذا.هيئ(مزايا: سند[مـزايا_مزامن])؛
```

</div>

```
handler this.init();
handler this.init(attr: ref[MutexAttributes]);
```

* `اقفل`: تستخدم لقفل المزامن ولا تستلم أي معطيات. عند استدعاء هذه الدالة يُلبث المسلك لحين تحرر هذا
  المزامن من أي قفل.

* `افتح`: تفتح القفل ما يتيح لنظام التشغيل تحرير أحد المسالك المُنتظِرة لهذا القفل.

### مـزايا_مزامن (MutexAttributes)

```
class MutexAttributes {
    def pshared: Int = 0;
    def kind: Int = 0;
    def protocol: Int = 0;
    def robustness: Int = 0;
}
```

### مـزايا_شرط (CondAttributes)

```
class CondAttributes {
    def dummy: Int = 0;
}
```

### مـحلي_لمسلك (ThreadLocal)

قالب أصناف يستخدم لإنشاء متغيرات محلية نسبة إلى مسلك، أي عمومية ضمن مسلك معين لكنها لا تُشارك مع
المسالك الأخرى.

* `مهيئ` (`initializer`): دالة مغلفة اختيارية تُستخدم لتهيئة المتغير وتُستدعى تلقائيا عند إنشاء
  المتغير ضمن مسلك محدد. أي أنها ستُستدعى لكل مسلك يتم إنشاء المتغير فيه.
  إذا لم يُحدد المهيئ فسيُكتفى بتهيئة المتغير باستخدام عمليات التهيئة الضمنية (constructors).
  يمكن تحديد قيمة المهيئ بتمريره إلى عملية تهيئة `مـحلي_لمسلك` أو بتغيير قيمة الخصلة لاحقًا بعد
  التهيئة.

* `القيمة` (`value`): تستخدم للوصول إلى القيمة الفعلية للمتغير. استخدام هذه الخصلة لأول مرة
  ضمن مسلك سيؤدي لحجز ذاكرة للمتغير وتهيئته قبل إرجاع القيمة.

المثال التالي يوضح استخدام هذا القالب:

<div dir=rtl>

```
عرف متغير: تـوازي.مـحلي_لمسلك[صـنفي](مغلفة(م: سند[صـنفي]) {
    م.ع = ريـاضيات.عشوائي()؛
})؛

// لاحقا ضمن دالة في مسلك:
طـرفية.اطبع(متغير.القيمة.ع)؛
```

</div>

```
def var: Threading.ThreadLocal[MyType](closure (val: ref[A]) {
    val.i = Math.random();
});

// Later from within a thread:
Console.print(var.value.i);
```

في هذا المثال نعرف `متغير` (`var`) ليحتوي على قيمة من صنف `صـنفي` (`MyType`) وعند إنشاء المتغير
ذو الصنف `صـنفي` ضمن مسلك معين تُحدد قيمة الخصلة `ع` (`i`) منه بقيمة عشوائية.


## مثال

<div dir="rtl">

```
اشمل "مـتم/طـرفية"؛
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Threading"، "تـوازي.أسس")؛

عرف مزامن: تـوازي.مـزامن؛
عرف مجموع: صحيح = 0؛
عرف تعداد: صحيح = 0؛

دالة مجموع_كلي {
    استخدم تـوازي؛

    مزامن.هيئ()؛
    عرف عدد_المسالك: 10؛
    عرف تعريف_توازي: مصفوفة[مـسلك, عدد_المسالك]؛
    عرف ع: صحيح؛

    // تهيئة المسالك.
    لكل ع = 0, ع <  عدد_المسالك, ع++ {
        أنشئ_مسلكا(تعريف_توازي(عدد_صح)~مؤشر, 0, دالة_جمع~مؤشر, 0)؛
    }

    // انتظار المسالك.
    لكل ع = 0, ع <  عدد_المسالك, ع++ {
        التق_بالمسلك(تعريف_توازي(ع), 0)؛
    }

    مـتم.طـرفية.اطبع("الناتج: %d\n", مجموع)؛
}

دالة دالة_جمع (ح: مؤشر): مؤشر {
    استخدم تـوازي؛

    // كل مسلك سيقوم بحساب مجموع 100 رقم، و بالتالي سيبدأ
    // المسلك الأول من الرقم 0 و الثاني من 100 و هكذا
    // لذلك يمكننا الحصول على بداية المجال عن طريق رقم
    // المسلك ضرب 100

    // زامن مع المسالك الأخرى قبل استخدام المتغير العمومي.
    مزامن.اقفل()؛
    عرف بداية: صحيح = تعداد*100؛
    تعداد++؛
    مزامن.افتح()؛

    عرف ع: صحيح؛
    لكل ع = بداية, ع <  بداية + 100, ع++ {
        // زامن مع المسالك الأخرى قبل استخدام المتغير العمومي.
        مزامن.اقفل()؛
        مجموع += ع؛
        مزامن.افتح()؛
    }
    ارجع 0؛
}

مجموع_كلي();
```

</div>

```
import "Srl/Console";
import "Apm";
Apm.importFile("Alusus/Threading");

def mutex: Threading.Mutex;
def sum: Int = 0;
def counter: Int = 0;

func totalSum {
    use Threading;

    mutex.init();

    def NTHREADS: 10;
    def threads: array[Thread, NTHREADS];
    def i: Int;

    // Create the threads.
    for i = 0, i < NTHREADS, i++ {
        createThread(threads(i)~ptr, 0, calculateSum~ptr, 0);
    }

    // Wait for the threads.
    for j = 0, j < NTHREADS, j++ {
        joinThread(threads(j), 0);
    }

    // Print output
    Srl.Console.print("The result is: %d\n", sum); // 499500
}

func calculateSum(p: ptr): ptr {
    use Threading;

    // Each thread calculates the sum of 100 numbers.
    // The first thread will compute the sum of the numbers from 0 to 100
    // and so on for the rest.

    // Sync with other threads before accessing the global var.
    mutex.lock();
    def st: Int = counter*100;
    counter++;
    mutex.unlock();

    def i: Int;
    for i = st, i < st + 100, i++ {
        // Sync with other threads before accessing the global var.
        mutex.lock();
        sum += i;
        mutex.unlock();
    }
    return 0;
}

totalSum();
```

