# تـوازي (Threading)
[[English]](readme.md)

مكتبة لإنشاء المسالك (threads) وتمكين المزامنة (synchronization) بينها في لغة الأسس.

## إضافة المكتبة للمشروع

أضف المكتبة لمشروعك باستخدام مدير الحزم:

```
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Threading"، "تـوازي.أسس")؛
```
‎
```
import "Apm";
Apm.importFile("Alusus/Threading");
```

## الدالات

### أنشئ_مسلكا (createThread)
```
    دالة أنشئ_مسلكا(
      مسلك: مؤشر[مـسلك]،
      مزايا: مؤشر[مـزايا_المسلك]،
      دالة_البداية: مؤشر[دالة (مؤشر): مؤشر]،
      معطى: مؤشر
    ): صـحيح؛
```
```
    func createThread(
      pthread: ptr[Thread],
      attr: ptr[ThreadAttributes],
      startRoutine: ptr[func (ptr): ptr],
      arg: ptr
    ): Int;
```
دالة  لإنشاء مسلك. تطابق هذه الدالة دالة `pthread_create` من Posix.

المعطيات:

`مسلك`: مؤشر إلى متغير من الصنف `مـسلك` (`Thread`) تُخزن فيه بيانات المسلك المُنشأ.

`مزايا`: السمات التي نريدها للمسلك.

`دالة_البداية`: مؤشر إلى الدالة التي ستُنفذ في المسلك الجديد.

`معطى`: مؤشر يتم تمريره للدالة عند تشغيل المسلك. يستخدم هذا المؤشر لتمرير أي بيانات نريد تمريرها للدالة.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### التق_بمسلك (joinThread)
```
    دالة التق_بمسلك(مسلك: مؤشر[مـسلك]، نتيجة: مؤشر[مؤشر]): صـحيح؛
```
```
    func joinThread(pthread: ptr[Thread], retval: ptr[ptr]): Int;
```
تنتظر مسلكا حتى يكتمل تنفيذه وتستلم منه القيمة المرجعة من دالة المسلك. هذه الدالة تطابق دالة `pthread_join` من Posix.

المعطيات:

`مسلك`: مؤشر للمسلك الذي نرغب بانتظاره.

`نتيجة`: مؤشر إلى المتغير الذي ستُخزن فيه نتيجة تنفيذ المسلك، أي القيمة المرجعة من دالة المسلك.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### هيئ_مزامنا (initMutex)
```
    دالة هيئ_مزامنا(مزامن: مؤشر[مـزامن]، مزايا: مؤشر[مـزايا_مزامن]): صـحيح؛
```
```
    func initMutex(mutex: ptr[Mutex], attrs: ptr[MutexAttributes]): Int;
```
تهيئ مزامنا. يجب تهيئة المزامن باستخدام هذه الدالة قبل التمكن من استخدامه.
هذه الدالة تطابق دالة `pthread_mutex_init` من Posix.

المعطيات:

`مزامن`: مؤشر إلى المزامن المراد تهيئته.

`مزايا`: المزايا المطلوبة لهذا المزامن. تمرير 0 يؤدي لتهيئة المزامن بالمزايا الافتراضية.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### اقفل_مزامنا (lockMutex)
```
    دالة اقفل_مزامنا(مزامن: مؤشر[مـزامن]): صـحيح؛
```
```
    func lockMutex(mutex: ptr[Mutex]): Int;
```
تقفل المزامن وتحجزه للمسلك الحالي. إن كان المزامن محجوزا من قبل مسلك آخر فسيُجمد هذا المسلك حتى يتم تحرير المزامن من قبل المسلك الآخر.
هذه الدالة تطابق دالة `pthread_mutex_lock` من Posix.

المعطيات:

`مزامن`: مؤشر على المزامن المراد قفله.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### حاول_قفل_مزامن (tryLockMutex)
```
    دالة حاول_قفل_مزامن(مزامن: مؤشر[مـزامن]): صـحيح؛
```
```
    func tryLockMutex(mutex: ptr[Mutex]): Int;
```
تقفل المزامن إذا كان حرًا، وتُرجع رمز خطأ مباشرة دون انتظار إذا كان المزامن محجوزًا من قبل مسلك آخر.
هذه الدالة تطابق دالة `pthread_mutex_trylock` من Posix.

المعطيات:

`مزامن`: مؤشر على المزامن المراد قفله.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### افتح_مزامنا (unlockMutex)
```
    دالة افتح_مزامنا(مزامن: مؤشر[مـزامن]): صـحيح؛
```
```
    func unlockMutex(mutex: ptr[Mutex]): Int;
```
تحرر مزامنًا وتجعله متوفرًا للمسالك الأخرى. هذه الدالة تطابق دالة `pthread_mutex_unlock` من Posix.

المعطيات:

`مزامن`: مؤشر إلى المزامن المراد تحريره.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### هيئ_شرطا (initCond)
```
    دالة هيئ_شرطا(شرط: مؤشر[شـرط]، مزايا: مؤشر[مـزايا_شرط]): صـحيح؛
```
```
    func initCond(cond: ptr[Cond], attrs: ptr[CondAttributes]): Int;
```
يهيئ كائنا من صنف `شـرط`. يجب تهيئة الشرط بهذه الدالة قبل استخدامه.
هذه الدالة تطابق دالة `pthread_cond_init` من Posix.

المعطيات:

`شرد`: مؤشر إلى الشرط المراد تهيئته.

`مزايا`: المزايا المطلوبة للشرط. تمرير 0 يؤدي إلى تهيئته بالمزايا الافتراضية.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### علم_شرطا (signalCond)
```
    دالة علم_شرطا(شرط: مؤشر[شـرط]): صـحيح؛
```
```
    func signalCond(cond: ptr[Cond]): Int;
```
يُرسل إشارة بأن الشرط المعني قد تحقق. يؤدي ذلك لتحرير مسلك واحد من المسالك المنتظرة لهذا الشرط. إن
وُجد عدة مسالك تنتظر الشرط فسيُحرر واحد منها فقط لكل استدعاء لهذه الدالة. قبل استدعاء هذه الدالة
يجب على المسلك قفل مزامن (نفس المزامن المستخدم من قبل المسالك التي تستدعي `انتظر_شرطا` `waitCond`) ويجب تحرير
المزامن بعد استدعاء هذه الدالة. المسلك الذي ينتظر تحقق الشرط باستخدام الدالة `انتظر_شرطا` `waitCond`
لن يُحرر حتى يُحرر هذا المزامن لأن دالة `انتظر_شرطا` ستسعى لقفل ذلك المزامن.
هذه الدالة تطابق دالة `pthread_cond_signal` من Posix.

المعطيات:

`شرط`: مؤشر إلى الشرط المراد تعليمه.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

### انتظر_شرطا (waitCond)
```
    دالة انتظر_شرطا(شرط: مؤشر[شـرط]، مزامن: مؤشر[مـزامن]): صـحيح؛
```
```
    func waitCond(cond: ptr[Cond], mutex: ptr[Mutex]): Int;
```
تنتظر تحقق شرط. تستقبل هذه الدالة مزامنا بالإضافة إلى الشرط المعني وتتطلب أن يكون المزامن مقفلًا
قبل استداءها. تعمل الدالة بشكل لا انشطاري (atomic) على تجميد المسلك وتحرير المزامن. عند تحقق
الشرط تقوم الدالة بشكل لا انشطاري بقفل المزامن مجددًا وتحرير المسلك.
هذه الدالة تطابق دالة `pthread_cond_wait` من Posix.

المعطيات:

`شرط`: مؤشر إلى الشرط المراد انتظار تحققه.

`مزامن`: مؤشر إلى مزامن. يجب أن يكون المزامن مقفلًا قبل استدعاء الدالة.

القيمة المرجعة:

تُرجع الدالة 0 في حالة نجاح العملية، ورمز خطئ في حالة فشلها.

## أصناف

```
class ThreadAttributes {
    def flags: Int;
    def stackSize: Int;
    def contentionScope: Int;
    def inheritSched: Int;
    def detachState: Int;
    def sched: Int;
    def param: SchedParam;
    def startTime: TimeSpec;
    def deadLine: TimeSpec;
    def period: TimeSpec;
}

class SchedParam {
    def schedPriority: Int;
}

class TimeSpec {
    def tvSec: ArchInt;
    def tvNsec: Int[64];
}

class MutexAttributes {
    def pshared: Int = 0;
    def kind: Int = 0;
    def protocol: Int = 0;
    def robustness: Int = 0;
}

class CondAttributes {
    def dummy: Int = 0;
}
```

## مثال

```
اشمل "مـتم/طـرفية"؛
اشمل "مـحا"؛
مـحا.اشمل_ملف("Alusus/Threading"، "تـوازي.أسس")؛

عرف كائن_مزامن: تـوازي.مـزامن؛
عرف مجموع: صحيح = 0؛
عرف تعداد: صحيح = 0؛

دالة مجموع_كلي {
    استخدم تـوازي؛

    عرف عدد_المسالك: 10؛
    عرف تعريف_توازي: مصفوفة[مـسلك, عدد_المسالك]؛
    عرف ع: صحيح؛

    // تهيئة المسالك.
    لكل ع = 0, ع <  عدد_المسالك, ع++ {
        أنشئ_مسلكا(تعريف_توازي(عدد_صح)~مؤشر, 0, دالة_جمع~مؤشر, 0)؛
    }

    // انتظار المسالك.
    لكل ع = 0, ع <  عدد_المسالك, ع++ {
        التق_بالمسلك(تعريف_توازي(ع), 0)؛
    }

    مـتم.طـرفية.اطبع("الناتج: %d\n", مجموع)؛
}

دالة دالة_جمع (ح: مؤشر): مؤشر {
    استخدم تـوازي؛

    // كل مسلك سيقوم بحساب مجموع 100 رقم، و بالتالي سيبدأ
    // المسلك الأول من الرقم 0 و الثاني من 100 و هكذا
    // لذلك يمكننا الحصول على بداية المجال عن طريق رقم
    // المسلك ضرب 100

    // زامن مع المسالك الأخرى قبل استخدام المتغير العمومي.
    اقفل_مزامنا(كائن_مزامن~مؤشر)؛
    عرف بداية: صحيح = تعداد*100؛
    تعداد++؛
    افتح_مزامنا(كائن_مزامن~مؤشر)؛

    عرف ع: صحيح؛
    لكل ع = بداية, ع <  بداية + 100, ع++ {
        // زامن مع المسالك الأخرى قبل استخدام المتغير العمومي.
        اقفل_مزامنا(كائن_مزامن~مؤشر)؛
        مجموع += ع؛
        افتح_مزامنا(كائن_مزامن~مؤشر)؛
    }
    ارجع 0؛
}

مجموع_كلي();

```

```
import "Srl/Console";
import "Apm";
Apm.importFile("Alusus/Threading");

def mutex: Threading.Mutex;
def sum: Int = 0;
def counter: Int = 0;

func totalSum {
    use Threading;

    initMutex(mutex~ptr, 0);

    def NTHREADS: 10;
    def threads: array[Thread, NTHREADS];
    def i: Int;

    // Create the threads.
    for i = 0, i < NTHREADS, i++ {
        createThread(threads(i)~ptr, 0, calculateSum~ptr, 0);
    }

    // Wait for the threads.
    for j = 0, j < NTHREADS, j++ {
        joinThread(threads(j), 0);
    }

    // Print output
    Srl.Console.print("The result is: %d\n", sum); // 499500
}

func calculateSum(p: ptr): ptr {
    use Threading;

    // Each thread calculates the sum of 100 numbers.
    // The first thread will compute the sum of the numbers from 0 to 100
    // and so on for the rest.

    // Sync with other threads before accessing the global var.
    lockMutex(mutex~ptr);
    def st: Int = counter*100;
    counter++;
    unlockMutex(mutex~ptr);

    def i: Int;
    for i = st, i < st + 100, i++ {
        // Sync with other threads before accessing the global var.
        lockMutex(mutex~ptr);
        sum += i;
        unlockMutex(mutex~ptr);
    }
    return 0;
}

totalSum();
```
